import { error, fail } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
import { z } from 'zod';
import { superValidate } from 'sveltekit-superforms/server';
import { zod } from 'sveltekit-superforms/adapters';
import { protect } from '$lib/auth/protect';
import {
	getAllDatabaseTables,
	getTableMetadata,
	countTableRows,
	getClient,
	type TableInfo as PrismaTableInfo,
	type FieldInfo
} from '$lib/prisma-meta';

// Types pour l'export
export interface ExportConfig {
	selectedTables: string[];
	format: 'xlsx' | 'csv' | 'xml';
	includeRelations: boolean;
	rowLimit?: number;
	filters: Record<string, unknown>;
	includeHeaders: boolean;
}

// Extension de TableInfo pour inclure les donn√©es d'export
export interface ExportTableInfo extends PrismaTableInfo {
	columns: FieldInfo[];
	relations?: string[];
}

export interface ExportResult {
	success: boolean;
	message: string;
	downloadUrl?: string;
	fileName?: string;
	fileSize?: number;
	exportedRows: number;
	warnings: string[];
	errors: string[];
	needsClientDownload?: boolean;
}

// Sch√©ma de validation pour l'export
const exportSchema = z.object({
	selectedTables: z.array(z.string()).min(1, 'S√©lectionnez au moins une table'),
	format: z.enum(['xlsx', 'csv', 'xml'], {
		errorMap: () => ({ message: 'Format non support√©' })
	}),
	includeRelations: z.boolean().default(false),
	rowLimit: z.number().min(1).max(1000000).optional(),
	filters: z.record(z.unknown()).default({}),
	includeHeaders: z.boolean().default(true),
	dateRange: z
		.object({
			from: z.string().optional(),
			to: z.string().optional()
		})
		.optional()
});

// G√©n√©ration des informations d'export √† partir des m√©tadonn√©es Prisma
async function generateExportTables(): Promise<ExportTableInfo[]> {
	// R√©cup√©rer toutes les tables des deux bases de donn√©es
	const tables = await getAllDatabaseTables();

	const tablesWithMetadata = await Promise.all(
		tables.map(async (table) => {
			const metadata = await getTableMetadata(table.database, table.name);
			const columns: FieldInfo[] = metadata?.fields || [];

			return {
				...table,
				columns,
				relations: []
			};
		})
	);

	return tablesWithMetadata;
}

// Obtenir les informations sur les tables avec le compte de lignes
async function getTablesInfo(): Promise<ExportTableInfo[]> {
	const availableTables = await generateExportTables();

	const tablesWithCounts = await Promise.all(
		availableTables.map(async (table) => {
			try {
				const count = await countTableRows(table.database, table.name);
				return {
					...table,
					rowCount: count
				};
			} catch {
				return {
					...table,
					rowCount: 0
				};
			}
		})
	);

	return tablesWithCounts;
}

export const load = (async (event) => {
	await protect(event);

	const { depends } = event;
	depends('app:export');

	try {
		const tables = await getTablesInfo();
		const form = await superValidate(zod(exportSchema));

		form.data = {
			selectedTables: [],
			format: 'csv',
			includeRelations: false,
			filters: {},
			includeHeaders: true
		};

		return {
			form,
			tables,
			totalTables: tables.length,
			totalRows: tables.reduce((sum, table) => sum + (table.rowCount || 0), 0)
		};
	} catch (err) {
		throw error(
			500,
			`Erreur lors du chargement de la page export: ${err instanceof Error ? err.message : 'Erreur inconnue'}`
		);
	}
}) satisfies PageServerLoad;

export const actions: Actions = {
	preview: async (event) => {
		await protect(event);

		const { request } = event;
		const form = await superValidate(request, zod(exportSchema));

		if (!form.valid) {
			return fail(400, { form });
		}

		try {
			const { selectedTables } = form.data;
			const previewData: Record<string, unknown[]> = {};

			// R√©cup√©rer un aper√ßu des donn√©es pour chaque table s√©lectionn√©e
			for (const tableId of selectedTables) {
				const limit = 5;

				// Parser l'ID de table pour extraire le vrai nom de table
				// Format attendu: "database-tablename" => extraire "tablename"
				const tableName = tableId.includes('-') ? tableId.split('-').slice(1).join('-') : tableId;
				console.log(`üîç [PREVIEW] Processing tableId: ${tableId} => tableName: ${tableName}`);

				try {
					// D√©terminer quelle base de donn√©es utiliser pour cette table
					const allTables = await getAllDatabaseTables();
					const tableInfo = allTables.find((t) => t.name === tableName);
					
					if (!tableInfo) {
						console.error(`‚ùå [PREVIEW] Table non trouv√©e: ${tableName} (from tableId: ${tableId})`);
						console.log(`üîç [PREVIEW] Tables disponibles:`, allTables.map(t => t.name));
						continue; // Passer √† la table suivante
					}
					
					const database = tableInfo.database;

					// Utiliser l'acc√®s dynamique aux mod√®les Prisma
					const prisma = await getClient(database);

					// eslint-disable-next-line @typescript-eslint/no-explicit-any
					const model = (prisma as Record<string, any>)[tableName];
					if (!model) {
						continue;
					}

					// D√©terminer la colonne pour l'ordre (cl√© primaire)
					const metadata = await getTableMetadata(database, tableName);
					const primaryKey = metadata?.primaryKey;
					const orderBy = primaryKey ? { [primaryKey]: 'asc' } : {};

					// R√©cup√©rer les donn√©es avec l'ordre appropri√©
					const data = await model.findMany({
						take: limit,
						...(Object.keys(orderBy).length > 0 && { orderBy })
					});

					// Utiliser le nom de table r√©el pour la cl√© de pr√©visualisation
					previewData[tableName] = data;
				} catch (error) {
					console.error(`‚ùå [PREVIEW] Erreur lors de la r√©cup√©ration des donn√©es pour ${tableName}:`, error);
					previewData[tableName] = [];
				}
			}

			return { form, success: true, preview: previewData };
		} catch {
			return fail(500, {
				form,
				error: "Erreur lors de l'aper√ßu des donn√©es"
			});
		}
	},

	export: async (event) => {
		await protect(event);

		const { request, fetch } = event;
		const form = await superValidate(request, zod(exportSchema));

		if (!form.valid) {
			return fail(400, { form });
		}

		try {
			// Transformer les IDs de tables en noms de tables r√©els avant l'envoi √† l'API
			const transformedData = {
				...form.data,
				selectedTables: form.data.selectedTables.map(tableId => 
					tableId.includes('-') ? tableId.split('-').slice(1).join('-') : tableId
				)
			};
			
			console.log('üîß [EXPORT] Transformation des IDs:', {
				original: form.data.selectedTables,
				transformed: transformedData.selectedTables
			});

			const response = await fetch('/export/api', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(transformedData)
			});

			const contentType = response.headers.get('content-type');

			if (!response.ok) {
				let errorData;
				try {
					errorData = await response.json();
				} catch {
					errorData = { error: "Erreur de communication avec l'API" };
				}
				return fail(response.status, {
					form,
					error: errorData.error || "Erreur lors de l'export"
				});
			}

			if (
				contentType &&
				(contentType.includes('application/vnd.openxml') ||
					contentType.includes('text/csv') ||
					contentType.includes('application/xml'))
			) {
				const exportResultHeader = response.headers.get('X-Export-Result');
				if (exportResultHeader) {
					const result = JSON.parse(exportResultHeader);
					const finalResult = { ...result, needsClientDownload: true, downloadUrl: '/export/api' };
					return { form, success: true, result: finalResult };
				}
			}

			let result;
			try {
				result = await response.json();
			} catch {
				return fail(500, {
					form,
					error: "Erreur lors du parsing de la r√©ponse d'export"
				});
			}

			return { form, success: true, result };
		} catch {
			return fail(500, {
				form,
				error: "Erreur lors de l'export des donn√©es"
			});
		}
	}
};

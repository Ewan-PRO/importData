// src/lib/prisma-meta.ts - Utilitaires PARTAG√âS pour m√©tadonn√©es Prisma DMMF
//
// ‚ö†Ô∏è R√àGLE IMPORTANTE : Ce fichier contient UNIQUEMENT des fonctions PARTAG√âES utilis√©es par PLUSIEURS pages/composants
//
// ‚úÖ √Ä METTRE ICI :
// - getTableMetadata() : utilis√© par import, export, kits, categories, etc.
// - getAllTables() : utilis√© par import, export, navigation, etc.
// - findRecord(), createRecord(), updateRecord() : CRUD g√©n√©rique pour toutes les tables
// - getDatabases() : acc√®s aux clients Prisma partag√©
//
// ‚ùå √Ä NE PAS METTRE ICI :
// - Sch√©mas Zod sp√©cifiques √† une page (ex: kitSchema ‚Üí dans +page.server.ts kits)
// - Fonctions m√©tier sp√©cifiques (ex: createKitWithTransaction ‚Üí dans +page.server.ts kits)
// - Logique UI sp√©cifique (ex: formatage pour DataTable ‚Üí dans le composant)
//
// üí° PRINCIPE : Si c'est utilis√© par 2+ pages = ici, sinon = dans la page concern√©e
import { browser, dev } from '$app/environment';

// Types pour les modules Prisma
interface PrismaModule {
	Prisma: {
		dmmf: {
			datamodel: {
				models: Array<{
					name: string;
					fields: Array<{
						name: string;
						type: string;
						isRequired: boolean;
						isId: boolean;
						kind: string;
					}>;
				}>;
			};
		};
	};
	PrismaClient: new () => Record<string, unknown>;
}

// Variables globales typ√©es
let Prisma: PrismaModule['Prisma'] | undefined;
let PrismaClient: PrismaModule['PrismaClient'] | undefined;
let prismaModule: PrismaModule | undefined;

// Import c√¥t√© serveur uniquement
async function initializePrisma() {
	if (!browser && !prismaModule) {
		const imported = (await import('@prisma/client')) as unknown as PrismaModule;
		prismaModule = imported;
		Prisma = imported.Prisma;
		PrismaClient = imported.PrismaClient;
	}
}

// Client de d√©veloppement typ√©
let CenovDevPrisma: PrismaModule['Prisma'] | undefined;
let CenovDevPrismaClient: PrismaModule['PrismaClient'] | undefined;

// Fonction helper pour d√©terminer si on utilise les vues dev (comme db.ts)
function shouldUseDevViews() {
	// Utiliser process.env directement (c√¥t√© serveur uniquement)
	if (browser) return false;
	return process.env.USE_DEV_VIEWS === 'true' || dev;
}

// Initialisation du client de d√©veloppement - Solution hybride dev/prod
async function initializeCenovDevPrisma() {
	if (browser) return;

	await initializePrisma();

	const useDevViews = shouldUseDevViews();
	console.log('üîç [PRISMA-META] Configuration:', {
		USE_DEV_VIEWS: process.env.USE_DEV_VIEWS,
		dev,
		useDevViews
	});

	// TOUJOURS charger le client dev si possible pour categorie_attribut
	console.log('‚úÖ [PRISMA-META] Chargement client dev (garantit les bonnes m√©tadonn√©es)');
	try {
		let devPrismaModule: PrismaModule | undefined;

		if (dev) {
			// DEV: createRequire (g√®re CommonJS)
			console.log('üõ†Ô∏è [PRISMA-META] Mode DEV - createRequire');
			try {
				const { createRequire } = await import('node:module');
				const { fileURLToPath } = await import('node:url');
				const path = await import('node:path');

				const __filename = fileURLToPath(import.meta.url);
				const __dirname = path.dirname(__filename);
				const require = createRequire(import.meta.url);

				const devPrismaPath = path.resolve(__dirname, '../../prisma/cenov_dev/generated');
				devPrismaModule = require(devPrismaPath) as unknown as PrismaModule;
				console.log('‚úÖ [PRISMA-META] createRequire r√©ussi');
			} catch (createRequireError) {
				console.log('‚ùå [PRISMA-META] createRequire √©chou√©:', createRequireError);
				throw createRequireError;
			}
		} else {
			// PROD: import() avec @vite-ignore (marche en production)
			console.log('üöÄ [PRISMA-META] Mode PROD - import()');
			try {
				const path = await import('node:path');
				const { pathToFileURL } = await import('node:url');
				const absolutePath = path.resolve(process.cwd(), 'prisma/cenov_dev/generated/index.js');
				const fileUrl = pathToFileURL(absolutePath).href;

				devPrismaModule = (await import(/* @vite-ignore */ fileUrl)) as unknown as PrismaModule;
			} catch {
				// Fallback import relatif
				devPrismaModule = (await import(
					/* @vite-ignore */ '../../prisma/cenov_dev/generated/index.js'
				)) as unknown as PrismaModule;
			}
			console.log('‚úÖ [PRISMA-META] import() r√©ussi');
		}

		if (devPrismaModule?.Prisma && devPrismaModule?.PrismaClient) {
			CenovDevPrisma = devPrismaModule.Prisma;
			CenovDevPrismaClient = devPrismaModule.PrismaClient;
			console.log('‚úÖ [PRISMA-META] Client dev charg√© avec succ√®s');
		} else {
			throw new Error('Module dev invalide - Prisma/PrismaClient manquants');
		}
	} catch (error) {
		console.log('‚ùå [PRISMA-META] Erreur client dev:', error);
		// Fallback au client principal
		CenovDevPrisma = Prisma;
		CenovDevPrismaClient = PrismaClient;
		console.log('‚ö™ [PRISMA-META] Utilisation client principal en fallback');
	}
}

export type DatabaseName = 'cenov' | 'cenov_dev';

export interface TableInfo {
	name: string;
	displayName: string;
	category: 'table' | 'view';
	database: DatabaseName;
	schema: string;
	rowCount?: number;
	columns?: FieldInfo[];
}

export interface FieldInfo {
	name: string;
	type: string;
	isRequired: boolean;
	isPrimaryKey: boolean;
	isTimestamp?: boolean;
	dbType?: string;
}

// Interface pour les bases de donn√©es
interface DatabaseConfig {
	cenov: {
		dmmf: PrismaModule['Prisma']['dmmf'];
		client: Record<string, unknown>;
	};
	cenov_dev: {
		dmmf: PrismaModule['Prisma']['dmmf'];
		client: Record<string, unknown>;
	};
}

// Cache pour les bases de donn√©es (singleton)
let databasesCache: DatabaseConfig | null = null;

// Fonction pour invalider le cache (utile pour le debugging et les recharges)
export function clearDatabaseCache() {
	databasesCache = null;
	console.log('üîÑ [PRISMA-META] Cache des bases de donn√©es vid√©');
}

// Configuration des bases - cr√©ation unique (c√¥t√© serveur uniquement)
async function createDatabases(): Promise<DatabaseConfig> {
	if (browser) {
		throw new Error('[PRISMA-META] createDatabases ne peut √™tre appel√© c√¥t√© client');
	}

	await initializePrisma();
	await initializeCenovDevPrisma();

	if (!Prisma || !PrismaClient || !CenovDevPrisma || !CenovDevPrismaClient) {
		throw new Error('[PRISMA-META] Modules Prisma non initialis√©s');
	}

	return {
		cenov: {
			dmmf: Prisma.dmmf,
			client: new PrismaClient()
		},
		cenov_dev: {
			dmmf: CenovDevPrisma.dmmf,
			client: new CenovDevPrismaClient()
		}
	};
}

// Acc√®s aux bases avec cache (c√¥t√© serveur uniquement)
export async function getDatabases(): Promise<DatabaseConfig> {
	if (browser) {
		throw new Error('[PRISMA-META] getDatabases ne peut √™tre appel√© c√¥t√© client');
	}

	if (!databasesCache) {
		databasesCache = await createDatabases();
	}

	return databasesCache;
}

// Obtenir m√©tadonn√©es d'une table sp√©cifique (c√¥t√© serveur uniquement)
// Type pour les mod√®les DMMF r√©els (avec support @@map)
type DMMFModelFromPrisma = PrismaModule['Prisma']['dmmf']['datamodel']['models'][number] & {
	dbName?: string; // Nom de la table/vue r√©elle (@@map)
	schema?: string; // Sch√©ma (@@schema)
};

// D√©tecter la cl√© primaire via DMMF Prisma
function detectPrimaryKeyFromDMMF(model: DMMFModelFromPrisma): string | null {
	// 1. Cl√© primaire simple (@id)
	const singlePK = model.fields.find((f) => f.isId);
	if (singlePK) {
		return singlePK.name;
	}

	// 2. Pour les vues : chercher le premier champ "id-like"
	const idLikeFields = model.fields.filter((f) =>
		f.name.match(/^(.*_id|id|pro_id|cat_id|atr_id|kit_id|fam_id|frs_id|par_id|kat_id)$/)
	);

	if (idLikeFields.length > 0) {
		return idLikeFields[0].name;
	}

	// 3. Dernier recours : premier champ
	if (model.fields.length > 0) {
		return model.fields[0].name;
	}

	return null;
}

export async function getTableMetadata(database: DatabaseName, tableName: string) {
	if (browser) {
		throw new Error('[PRISMA-META] getTableMetadata ne peut √™tre appel√© c√¥t√© client');
	}

	const databases = await getDatabases();
	const model = databases[database].dmmf.datamodel.models.find((m) => m.name === tableName);
	if (!model) return null;

	// D√©tecter la cl√© primaire intelligemment
	const primaryKey = detectPrimaryKeyFromDMMF(model) || 'id';

	// Extraire le sch√©ma depuis les m√©tadonn√©es Prisma
	const schema = (model as { schema?: string }).schema || 'public';

	return {
		name: model.name,
		primaryKey,
		schema, // Nouveau champ pour le sch√©ma
		fields: model.fields
			.filter((f) => f.kind === 'scalar')
			.map((f) => ({
				name: f.name,
				type: f.type,
				isRequired: f.isRequired,
				isPrimaryKey: f.isId || false,
				// D√©tecter les timestamps (DateTime + noms courants)
				isTimestamp:
					f.type === 'DateTime' &&
					/^(created_at|updated_at|deleted_at|timestamp|date_|.*_at)$/i.test(f.name),
				dbType: f.type
			}))
	};
}

// Obtenir toutes les tables d'une base (c√¥t√© serveur uniquement)
export async function getAllTables(database: DatabaseName): Promise<TableInfo[]> {
	if (browser) {
		throw new Error('[PRISMA-META] getAllTables ne peut √™tre appel√© c√¥t√© client');
	}

	const databases = await getDatabases();
	const tables = databases[database].dmmf.datamodel.models.map((model) => {
		const modelWithMeta = model as DMMFModelFromPrisma;

		// Utiliser le nom @@map si disponible, sinon le nom du mod√®le
		const realTableName = modelWithMeta.dbName || model.name;

		const category: 'table' | 'view' =
			realTableName.startsWith('v_') || realTableName.includes('_v_') ? 'view' : 'table';

		// Utiliser le nom mapp√© (@@map) comme displayName par d√©faut
		let displayName = realTableName;
		const schema = modelWithMeta.schema || 'public';

		// Nettoyer uniquement les pr√©fixes automatiques √©vidents (comme public_)
		// MAIS GARDER les vrais noms de tables qui contiennent le nom du sch√©ma
		if (realTableName.startsWith('public_') && schema === 'public') {
			const cleanName = realTableName.substring(7); // 'public_'.length = 7
			displayName = cleanName;
		}

		// Extraire les informations sur les colonnes depuis le mod√®le DMMF
		const columns = model.fields
			.filter((f) => f.kind === 'scalar')
			.map((f) => ({
				name: f.name,
				type: f.type,
				isRequired: f.isRequired,
				isPrimaryKey: f.isId || false,
				isTimestamp:
					f.type === 'DateTime' &&
					/^(created_at|updated_at|deleted_at|timestamp|date_|.*_at)$/i.test(f.name),
				dbType: f.type
			}));

		return {
			name: model.name, // Garder le nom de mod√®le Prisma pour l'acc√®s programmatique
			displayName, // Utiliser le nom @@map pour l'affichage
			category,
			database,
			schema,
			columns
		};
	});
	return tables;
}

// Obtenir toutes les tables des 2 bases (c√¥t√© serveur uniquement)
export async function getAllDatabaseTables(): Promise<TableInfo[]> {
	if (browser) {
		throw new Error('[PRISMA-META] getAllDatabaseTables ne peut √™tre appel√© c√¥t√© client');
	}

	const cenovTables = await getAllTables('cenov');
	const cenovDevTables = await getAllTables('cenov_dev');
	const allTables = [...cenovTables, ...cenovDevTables];

	// Tri uniforme : par database ‚Üí par sch√©ma ‚Üí par type (tables avant vues) ‚Üí par nom
	const sortedTables = allTables.sort((a, b) => {
		// D√©finir la priorit√© des databases
		const getDatabaseOrder = (database: string) => {
			if (database === 'cenov') return 1;
			if (database === 'cenov_dev') return 2;
			return 3;
		};

		// D√©finir la priorit√© des sch√©mas
		const getSchemaOrder = (schema: string) => {
			if (schema === 'produit') return 1;
			if (schema === 'public') return 2;
			return 3;
		};

		// D√©finir la priorit√© du type (table avant vue)
		const getTypeOrder = (category: 'table' | 'view') => (category === 'table' ? 1 : 2);

		const aDatabaseOrder = getDatabaseOrder(a.database);
		const bDatabaseOrder = getDatabaseOrder(b.database);
		const aSchemaOrder = getSchemaOrder(a.schema);
		const bSchemaOrder = getSchemaOrder(b.schema);
		const aTypeOrder = getTypeOrder(a.category);
		const bTypeOrder = getTypeOrder(b.category);

		// 1. Comparer par database
		if (aDatabaseOrder !== bDatabaseOrder) {
			return aDatabaseOrder - bDatabaseOrder;
		}

		// 2. Comparer par sch√©ma dans la m√™me database
		if (aSchemaOrder !== bSchemaOrder) {
			return aSchemaOrder - bSchemaOrder;
		}

		// 3. Comparer par type dans le m√™me sch√©ma (tables avant vues)
		if (aTypeOrder !== bTypeOrder) {
			return aTypeOrder - bTypeOrder;
		}

		// 4. Tri alphab√©tique par nom dans le m√™me type
		return a.displayName.localeCompare(b.displayName);
	});

	return sortedTables;
}

// Obtenir tous les noms de bases de donn√©es
export async function getAllDatabaseNames(): Promise<DatabaseName[]> {
	if (browser) {
		return ['cenov', 'cenov_dev'];
	}

	const databases = await getDatabases();
	return Object.keys(databases) as DatabaseName[];
}

// Obtenir client Prisma (c√¥t√© serveur uniquement)
export async function getClient(database: DatabaseName): Promise<Record<string, unknown>> {
	if (browser) {
		throw new Error('[PRISMA-META] getClient ne peut √™tre appel√© c√¥t√© client');
	}

	const databases = await getDatabases();

	if (!databases[database]) {
		throw new Error(
			`[PRISMA-META] Database '${database}' not found in getClient. Available: ${Object.keys(databases).join(', ')}`
		);
	}

	if (!databases[database].client) {
		throw new Error(`[PRISMA-META] Client not found for database '${database}'`);
	}

	return databases[database].client;
}

// Compter lignes d'une table (c√¥t√© serveur uniquement)
export async function countTableRows(database: DatabaseName, tableName: string): Promise<number> {
	if (browser) {
		throw new Error('[PRISMA-META] countTableRows ne peut √™tre appel√© c√¥t√© client');
	}

	try {
		const client = await getClient(database);
		const model = client[tableName] as { count: () => Promise<number> } | undefined;
		return model ? await model.count() : 0;
	} catch {
		return 0;
	}
}

// ========== FONCTIONS POUR L'IMPORT ==========

// Fonction pour parser le format "database:tableName"
export function parseTableIdentifier(tableIdentifier: string): {
	database: DatabaseName;
	tableName: string;
} {
	const [database, tableName] = tableIdentifier.split(':');
	return { database: database as DatabaseName, tableName };
}

// Fonction pour d√©tecter automatiquement la database d'une table via parser
export async function detectDatabaseForTable(tableIdentifier: string): Promise<DatabaseName> {
	if (browser) {
		throw new Error('[PRISMA-META] detectDatabaseForTable ne peut √™tre appel√© c√¥t√© client');
	}

	// Parser le format "database:tableName" directement
	const { database } = parseTableIdentifier(tableIdentifier);
	return database;
}

// Types pour les r√®gles de validation d'import
export interface ValidationRules {
	requiredFields: string[];
	uniqueFields: string[];
	validators: Record<string, (value: unknown) => boolean>;
}

// Obtenir les r√®gles de validation pour une table via DMMF (c√¥t√© serveur uniquement)
export async function getTableValidationRules(
	database: DatabaseName,
	tableName: string
): Promise<ValidationRules> {
	if (browser) {
		throw new Error('[PRISMA-META] getTableValidationRules ne peut √™tre appel√© c√¥t√© client');
	}

	const metadata = await getTableMetadata(database, tableName);
	if (!metadata) {
		return {
			requiredFields: [],
			uniqueFields: [],
			validators: {}
		};
	}

	const databases = await getDatabases();
	const model = databases[database].dmmf.datamodel.models.find((m) => m.name === tableName);
	if (!model) {
		return {
			requiredFields: [],
			uniqueFields: [],
			validators: {}
		};
	}

	// Champs requis : d√©tect√©s via isRequired et non isOptional du DMMF
	const requiredFields = metadata.fields
		.filter((field) => field.isRequired && !field.isPrimaryKey)
		.map((field) => field.name);

	// Champs uniques : d√©tect√©s via les contraintes du DMMF
	const uniqueFields = getUniqueFieldsFromDMMF(model);

	// Validators : g√©n√©r√©s automatiquement selon les types Prisma
	const validators = generateValidatorsFromDMMF(metadata.fields);

	return {
		requiredFields,
		uniqueFields,
		validators
	};
}

// Fonction helper pour d√©tecter les champs uniques via DMMF
function getUniqueFieldsFromDMMF(model: Record<string, unknown>): string[] {
	const uniqueFields: string[] = [];

	// 1. Champs avec @id
	const fields = model.fields as Array<{ name: string; isId?: boolean; isUnique?: boolean }>;
	if (fields) {
		const idFields = fields.filter((f) => f.isId);
		idFields.forEach((field) => {
			if (!uniqueFields.includes(field.name)) {
				uniqueFields.push(field.name);
			}
		});

		// 2. Champs avec @unique
		const uniqueSingleFields = fields.filter((f) => f.isUnique);
		uniqueSingleFields.forEach((field) => {
			if (!uniqueFields.includes(field.name)) {
				uniqueFields.push(field.name);
			}
		});
	}

	// 3. Contraintes compos√©es @@unique et @@id
	const uniqueIndexes = model.uniqueIndexes as Array<{ fields?: string[] }> | undefined;
	if (uniqueIndexes) {
		uniqueIndexes.forEach((index) => {
			if (index.fields) {
				index.fields.forEach((fieldName) => {
					if (!uniqueFields.includes(fieldName)) {
						uniqueFields.push(fieldName);
					}
				});
			}
		});
	}

	// 4. Cl√© primaire composite @@id
	const primaryKey = model.primaryKey as { fields?: string[] } | undefined;
	if (primaryKey && primaryKey.fields) {
		primaryKey.fields.forEach((fieldName) => {
			if (!uniqueFields.includes(fieldName)) {
				uniqueFields.push(fieldName);
			}
		});
	}

	return uniqueFields;
}

// Fonction helper pour g√©n√©rer les validators automatiquement
function generateValidatorsFromDMMF(
	fields: FieldInfo[]
): Record<string, (value: unknown) => boolean> {
	const validators: Record<string, (value: unknown) => boolean> = {};

	fields.forEach((field) => {
		validators[field.name] = createValidatorForField(field);
	});

	return validators;
}

// Cr√©er un validator pour un champ selon son type DMMF
function createValidatorForField(field: FieldInfo): (value: unknown) => boolean {
	return (value: unknown) => {
		// Si champ optionnel et valeur vide, c'est valide
		if (!field.isRequired && (value === null || value === undefined || value === '')) {
			return true;
		}

		// Si champ requis et valeur vide, c'est invalide
		if (field.isRequired && (value === null || value === undefined || value === '')) {
			return false;
		}

		// Validation selon le type Prisma
		switch (field.type) {
			case 'String':
				if (typeof value !== 'string') return false;
				// Limite de longueur bas√©e sur les conventions du projet
				return getStringLengthLimit(field.name, value);

			case 'Int':
			case 'BigInt': {
				const numValue = Number(value);
				return !isNaN(numValue) && Number.isInteger(numValue);
			}

			case 'Float':
			case 'Decimal': {
				const floatValue = Number(value);
				return !isNaN(floatValue);
			}

			case 'Boolean':
				return (
					typeof value === 'boolean' ||
					value === 'true' ||
					value === 'false' ||
					value === '1' ||
					value === '0'
				);

			case 'DateTime':
				if (value instanceof Date) return !isNaN(value.getTime());
				if (typeof value === 'string') {
					const date = new Date(value);
					return !isNaN(date.getTime());
				}
				return false;

			default:
				// Pour les types inconnus, accepter si c'est une string non vide
				return typeof value === 'string' && value.length > 0;
		}
	};
}

// Fonction helper pour les limites de longueur des strings (limite g√©n√©rique)
function getStringLengthLimit(fieldName: string, value: string): boolean {
	// Limite g√©n√©rique pour tous les champs string
	// Les contraintes sp√©cifiques sont g√©r√©es par les validators Prisma DMMF
	return value.length <= 1000; // Limite raisonnable g√©n√©rale
}

// Obtenir toutes les tables importables (tables uniquement, pas les vues) (c√¥t√© serveur uniquement)
export async function getImportableTables(): Promise<TableInfo[]> {
	if (browser) {
		throw new Error('[PRISMA-META] getImportableTables ne peut √™tre appel√© c√¥t√© client');
	}

	const allTables = await getAllDatabaseTables();

	// Inclure √† la fois les tables et les vues pour l'import
	const importableTables = allTables.filter(
		(table) => table.category === 'table' || table.category === 'view'
	);

	// Ajouter le comptage des lignes comme dans l'export
	const tablesWithCounts = await Promise.all(
		importableTables.map(async (table) => {
			try {
				const count = await countTableRows(table.database, table.name);
				return {
					...table,
					rowCount: count
				};
			} catch {
				return {
					...table,
					rowCount: 0
				};
			}
		})
	);

	return tablesWithCounts;
}

// Obtenir les champs disponibles pour les tables importables (c√¥t√© serveur uniquement)
export async function getImportableTableFields(): Promise<Record<string, string[]>> {
	if (browser) {
		throw new Error('[PRISMA-META] getImportableTableFields ne peut √™tre appel√© c√¥t√© client');
	}

	const tables = await getImportableTables();
	const result: Record<string, string[]> = {};

	for (const table of tables) {
		const metadata = await getTableMetadata(table.database, table.name);
		if (metadata) {
			// Utiliser database:tableName comme cl√© pour √©viter les collisions
			const key = `${table.database}:${table.name}`;
			result[key] = metadata.fields.map((field) => field.name);
		}
	}

	return result;
}

// Obtenir les champs requis pour les tables importables (c√¥t√© serveur uniquement)
export async function getImportableTableRequiredFields(): Promise<Record<string, string[]>> {
	if (browser) {
		throw new Error(
			'[PRISMA-META] getImportableTableRequiredFields ne peut √™tre appel√© c√¥t√© client'
		);
	}

	const tables = await getImportableTables();
	const result: Record<string, string[]> = {};

	for (const table of tables) {
		const validationRules = await getTableValidationRules(table.database, table.name);
		// Utiliser database:tableName comme cl√© pour √©viter les collisions
		const key = `${table.database}:${table.name}`;
		result[key] = validationRules.requiredFields;
	}

	return result;
}

// ========== FONCTIONS D'ANALYSE DES VUES ==========

// Parser SQL pour extraire les noms de tables
function parseTablesFromSQL(sqlDefinition: string): string[] {
	const tables = new Set<string>();

	// Regex am√©lior√©e pour capturer FROM/JOIN avec sch√©ma optionnel
	// Capture: schema.table ou table, mais retourne seulement le nom de la table
	const tableRegex = /(?:FROM|JOIN)\s+(?:\w+\.)?([a-zA-Z_][a-zA-Z0-9_]*)/gi;
	let match;

	while ((match = tableRegex.exec(sqlDefinition)) !== null) {
		const tableName = match[1];
		// Exclure les alias et mots-cl√©s
		if (tableName && !['ON', 'WHERE', 'AND', 'OR'].includes(tableName.toUpperCase())) {
			tables.add(tableName);
		}
	}

	// Parser sp√©cifique pour les sous-requ√™tes avec schema.table
	const schemaTableRegex = /(?:FROM|JOIN)\s+([a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*)/gi;
	let schemaMatch;

	while ((schemaMatch = schemaTableRegex.exec(sqlDefinition)) !== null) {
		const fullName = schemaMatch[1];
		// Extraire seulement le nom de la table (apr√®s le point)
		const tableName = fullName.split('.')[1];
		if (tableName) {
			tables.add(tableName);
		}
	}

	console.log(`üîç [SQL-PARSER] SQL analys√©:`, sqlDefinition);
	console.log(`üìã [SQL-PARSER] Tables d√©tect√©es:`, Array.from(tables));

	return Array.from(tables);
}

// Obtenir les tables sources d'une vue via analyse SQL PostgreSQL
async function getViewSourceTablesFromSQL(
	database: DatabaseName,
	viewName: string
): Promise<string[]> {
	if (browser) {
		throw new Error('[PRISMA-META] getViewSourceTablesFromSQL ne peut √™tre appel√© c√¥t√© client');
	}

	try {
		const client = await getClient(database);

		console.log(`üîç [PRISMA-META] Analyse SQL pour vue ${viewName} dans ${database}`);

		// PostgreSQL : obtenir la d√©finition compl√®te de la vue
		const result = await (
			client as {
				$queryRaw: (
					query: TemplateStringsArray,
					...values: unknown[]
				) => Promise<Array<{ definition: string }>>;
			}
		).$queryRaw`
			SELECT pg_get_viewdef(c.oid) as definition
			FROM pg_class c
			JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE c.relname = ${viewName} AND c.relkind = 'v'
		`;

		console.log(
			`üìã [PRISMA-META] D√©finition SQL r√©cup√©r√©e pour ${viewName}:`,
			result[0]?.definition
		);

		if (result[0]?.definition) {
			const tables = parseTablesFromSQL(result[0].definition);
			console.log(`üìä [PRISMA-META] Tables d√©tect√©es pour ${viewName}:`, tables);
			return tables;
		}

		console.log(`‚ö†Ô∏è [PRISMA-META] Aucune d√©finition trouv√©e pour la vue ${viewName}`);
		return [];
	} catch (error) {
		console.error(`‚ùå [PRISMA-META] Erreur lors de l'analyse SQL de la vue ${viewName}:`, error);
		return [];
	}
}

// Fonction de r√©solution automatique des cibles d'import
export async function resolveImportTarget(tableIdentifier: string): Promise<{
	isView: boolean;
	targetTables: string[];
	originalSelection: string;
}> {
	if (browser) {
		throw new Error('[PRISMA-META] resolveImportTarget ne peut √™tre appel√© c√¥t√© client');
	}

	const { database, tableName } = parseTableIdentifier(tableIdentifier);

	// D√©tecter si c'est une vue
	const isView = tableName.startsWith('v_') || tableName.includes('_v_');

	if (isView) {
		const sourceTables = await getViewSourceTablesFromSQL(database, tableName);
		return {
			isView: true,
			targetTables: sourceTables,
			originalSelection: tableIdentifier
		};
	}

	return {
		isView: false,
		targetTables: [tableName],
		originalSelection: tableIdentifier
	};
}

// ========== FONCTIONS CRUD G√âN√âRIQUES ==========

// Cr√©er un enregistrement de mani√®re g√©n√©rique (c√¥t√© serveur uniquement)
export async function createRecord(
	database: DatabaseName,
	tableName: string,
	data: Record<string, unknown>
): Promise<Record<string, unknown>> {
	if (browser) {
		throw new Error('[PRISMA-META] createRecord ne peut √™tre appel√© c√¥t√© client');
	}


	const client = await getClient(database);
	const model = client[tableName] as {
		create: (args: { data: unknown }) => Promise<Record<string, unknown>>;
	};

	if (!model || !model.create) {
		throw new Error(`Table ${tableName} not found in database ${database}`);
	}

	return await model.create({ data });
}

// Mettre √† jour un enregistrement de mani√®re g√©n√©rique (c√¥t√© serveur uniquement)
export async function updateRecord(
	database: DatabaseName,
	tableName: string,
	where: Record<string, unknown>,
	data: Record<string, unknown>
): Promise<{ count: number }> {
	if (browser) {
		throw new Error('[PRISMA-META] updateRecord ne peut √™tre appel√© c√¥t√© client');
	}

	const client = await getClient(database);
	const model = client[tableName] as {
		updateMany: (args: { where: unknown; data: unknown }) => Promise<{ count: number }>;
	};

	if (!model || !model.updateMany) {
		throw new Error(`Table ${tableName} not found in database ${database}`);
	}


	return await model.updateMany({ where, data });
}

// Trouver un enregistrement de mani√®re g√©n√©rique (c√¥t√© serveur uniquement)
export async function findRecord(
	database: DatabaseName,
	tableName: string,
	where: Record<string, unknown>
): Promise<Record<string, unknown> | null> {
	if (browser) {
		throw new Error('[PRISMA-META] findRecord ne peut √™tre appel√© c√¥t√© client');
	}

	const client = await getClient(database);
	const model = client[tableName] as {
		findFirst: (args: { where: unknown }) => Promise<Record<string, unknown> | null>;
	};

	if (!model || !model.findFirst) {
		throw new Error(`Table ${tableName} not found in database ${database}`);
	}

	return await model.findFirst({ where });
}

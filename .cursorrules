# Règles de développement pour ImportData

## Environnement et outils

- Utiliser **pnpm** comme gestionnaire de paquets (jamais npm)
- Stack : SvelteKit + TypeScript + PostgreSQL + Prisma + TailwindCSS
- Authentification via Logto
- Tests avec Vitest

## Commandes essentielles

**Développement :**

```bash
pnpm dev                  # Serveur de développement
pnpm build && pnpm preview  # Build et aperçu
pnpm lint && pnpm format  # Qualité du code
pnpm check                # Vérification TypeScript
pnpm test:unit            # Tests unitaires
```

**Prisma - CENOV (Production) :**

```bash
pnpm prisma:generate      # Génération client Prisma
pnpm prisma:migrate       # Migrations base de données
pnpm prisma:studio        # Interface Prisma Studio
pnpm prisma:push          # Push schéma vers BDD
pnpm prisma:pull          # Pull schéma depuis BDD
```

**Prisma - CENOV_DEV (Développement) :**

```bash
pnpm prisma:generate-dev  # Génération client dev
pnpm prisma:migrate-dev   # Migrations dev
pnpm prisma:studio-dev    # Studio dev
pnpm prisma:push-dev      # Push schéma dev
pnpm prisma:pull-dev      # Pull schéma dev
```

**Clients Prisma :**

```bash
pnpm prisma:generate-all  # Génération des deux clients
```

**Scripts BDD-IA (Export base de données) :**

```bash
node scripts/BDD-IA/fetch-all-tables.mjs    # Export toutes les tables
node scripts/BDD-IA/fetch-all-views.mjs     # Export toutes les vues
node scripts/BDD-IA/fetch-cenov-data.mjs    # Export complet (recommandé)
```

## Architecture et fichiers clés

- `src/routes/` : Pages SvelteKit (categories, kits, import, products)
- `src/lib/components/` : Composants réutilisables + UI library
- `src/lib/schemas/dbSchema.ts` : Schémas Zod pour validation
- `prisma/cenov/schema.prisma` : Schéma principal base de données CENOV
- `prisma/cenov_dev/schema.prisma` : Schéma base de données CENOV_DEV

## Workflow Prisma

1. Éditer `prisma/cenov/schema.prisma` (ou `prisma/cenov_dev/schema.prisma`)
2. Exécuter les commandes Prisma directement sur le schéma principal

## Base de données

**Architecture double base :**

- **CENOV Database** (`DATABASE_URL`) - Base principale production
- **CENOV_DEV Database** (`CENOV_DEV_DATABASE_URL`) - Base développement étendue

**Clients Prisma :**

```typescript
// Base CENOV (principale) :
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

// Base CENOV_DEV :
import { PrismaClient as CenovDevPrismaClient } from '../../prisma/cenov_dev/generated';
const cenovDevPrisma = new CenovDevPrismaClient();
```

**Métadonnées Prisma :**

- Utiliser `src/lib/prisma-meta.ts` pour métadonnées centralisées
- Éviter valeurs hardcodées, utiliser Prisma DMMF
- Fonctions : `getDatabases()`, `getTableMetadata()`, `getAllTables()`

- Système hiérarchique kits/pièces
- Tables : kits, attributes, parts, documents
- Vues matérialisées : v_categories, v_kit_carac (+ variantes \_dev)
- Support prod/dev avec tables séparées
- **Données complètes disponibles** : Toutes les données Cenov (12 tables, 4 vues) exportées en JSON dans `scripts/BDD-IA/output/` pour analyse IA

## Conventions de code

- camelCase pour fonctions et variables
- Typage strict TypeScript - **ÉVITER `any`, utiliser `unknown`**
- Programmation fonctionnelle privilégiée
- async/await plutôt que callbacks
- Early returns pour éviter imbrication
- const/let jamais var
- Template literals plutôt que concaténation
- Gestion erreurs explicite avec try/catch
- Fonctions pures sans effets de bord
- Principes DRY, KISS, YAGNI

**TypeScript - Remplacements recommandés :**

```typescript
// ❌ Éviter
const data: any[] = [];
const previewData: Record<string, any[]> = {};

// ✅ Utiliser
const data: unknown[] = [];
const previewData: Record<string, unknown[]> = {};
```

## Authentification

- Routes protégées via `src/lib/auth/protect.ts`
- Gestion session dans layouts
- Callback OAuth dans `/authentication-callback`

## Import Excel

- Fonctionnalité import dans `/import` et `/products/import`
- Support catégories, attributs, hiérarchies kits

## Tests

- Tests d'intégration dans `tests/integration/`
- CRUD operations pour categories et kits
- Tests de fonctionnalité import

## Composants UI

- Composants personnalisés basés sur bits-ui et Flowbite
- Validation formulaires avec Zod + SvelteKit Superforms
- Structure dans `src/lib/components/ui/`

**Button variants :**

- `bleu` (default) - Primary blue button
- `vert` - Success/confirmation actions
- `rouge` - Danger/delete actions
- `jaune` - Warning actions
- `noir` - Secondary dark actions
- `blanc` - Alternative/outline style
- `link` - Text link style

**Note:** `outline` variant n'existe pas - utiliser `blanc` pour style outline.

**Badge variants :**

- `default` (default) - Primary badge style
- `bleu` - Blue informational badge
- `vert` - Success/positive badge
- `rouge` - Error/danger badge
- `noir` - Secondary/neutral badge
- `blanc` - Alternative/outline style badge
- `orange` - Modification badge

**Note:** `outline` variant n'existe pas pour badges - utiliser `blanc` pour style outline.

## Toast Notifications (Sonner)

**Setup :** svelte-sonner installé, Toaster configuré dans +layout.svelte

**Usage correct :**

```typescript
// ✅ Import correct
import { toast } from 'svelte-sonner';
import { Toaster } from 'svelte-sonner';

// ✅ Usage
toast.error("Message d'erreur");
toast.success('Opération réussie');
toast('Message info');
```

**Erreurs à éviter :**

```typescript
// ❌ N'JAMAIS importer depuis les composants UI
import { toast } from '$lib/components/ui/sonner';
```

**Timing :**

- Toasts au chargement : `setTimeout(() => toast.error('msg'), 100)` dans `onMount`
- Handlers événements : appel direct sans délai
- Après navigation : fonctionne immédiatement

## Réponses en français

- Toujours répondre en français
- Être concis, éviter phrases de remplissage
- Montrer seulement lignes changées avec contexte minimal
- Anticiper besoins et suggérer solutions

## Bug Windows - Chemins de fichiers

**Contournement obligatoire pour les opérations sur fichiers :**

Lorsque Claude Code ne peut pas modifier un fichier sur Windows, utiliser TOUJOURS des chemins absolus Windows avec lettres de lecteur et barres obliques inverses :

```bash
# ✅ CORRECT - Chemins absolus Windows
C:\Users\EwanSenergous\OneDrive - jll.spear\Bureau\Projet\importData\file.js

# ❌ FAUX - Chemins relatifs ou Unix échouent
./file.js
/c/Users/.../file.js
```

**Appliquer à tous les outils :**
- Read : Toujours `C:\...`
- Write : Toujours `C:\...`
- Edit : Toujours `C:\...`
- MultiEdit : Toujours `C:\...`

Cette solution contourne les conflits de modification de fichiers sur Windows.

## Svelte 5 Runes - State Management Best Practices

### Partage d'état réactif entre composants

**Problème courant :** Partager des données modifiables entre composant parent et enfant avec Svelte 5 runes.

### ❌ Mauvaises pratiques à éviter

**1. Synchronisation bidirectionnelle avec `$:`**

```typescript
// ❌ BAD - Crée des boucles infinies et des conflits
// Parent
let mappedFields = {};
$: {
    mappedFieldsStore.set(mappedFields); // Met à jour le store
}

// Enfant
let mappedFields = $derived($mappedFieldsStore); // Lit le store
// Résultat : Boucle infinie de mises à jour !
```

**2. Props complexes avec `$bindable()` pour objets**

```typescript
// ❌ BAD - Difficile à débugger, problèmes de timing
// Parent
<TableSelector bind:mappedFields />

// Enfant
let { mappedFields = $bindable({}) } = $props();
// Problème : Ne se met pas à jour automatiquement au démarrage
```

**3. Fonctions non-réactives pour calculs dérivés**

```typescript
// ❌ BAD - Ne se recalcule pas automatiquement
function getRequiredFieldsStatus(tableId) {
    const mapped = Object.values(mappedFields).includes(field);
    return mapped ? 'vert' : 'rouge';
}
// Problème : mappedFields change mais la fonction ne se met pas à jour
```

### ✅ Bonnes pratiques recommandées

**1. Store comme source unique de vérité**

```typescript
// ✅ GOOD - Store centralisé
// src/lib/stores/mappedFields.ts
import { writable } from 'svelte/store';
export const mappedFields = writable<Record<string, string>>({});

// Parent - Écrit dans le store
import { mappedFields } from '$lib/stores/mappedFields';
function updateMapping() {
    mappedFields.set(newData); // Source unique de vérité
}

// Enfant - Lit du store
import { mappedFields as mappedFieldsStore } from '$lib/stores/mappedFields';
let mappedFields = $derived($mappedFieldsStore); // Lecture seule
```

**2. Calculs réactifs avec `$derived`**

```typescript
// ✅ GOOD - Se recalcule automatiquement
let requiredStatus = $derived(() => {
    const mapped = Object.values(mappedFields).includes(field);
    return mapped ? 'vert' : 'rouge';
});
// Avantage : Se met à jour automatiquement quand mappedFields change
```

**3. Mise à jour unidirectionnelle**

```typescript
// ✅ GOOD - Flux de données clair
// Seules les actions utilisateur et la logique métier mettent à jour le store
function onFieldSelect(value) {
    mappedFields.update(fields => ({...fields, [index]: value}));
}

function guessFieldMapping() {
    const newMappings = calculateMappings();
    mappedFields.set(newMappings); // Une seule source de mise à jour
}
```

### Règles d'or pour le state management

1. **Une source de vérité** : Store > Props pour données partagées complexes
2. **Flux unidirectionnel** : Éviter la synchronisation bidirectionnelle
3. **Réactivité explicite** : Utiliser `$derived` pour les calculs dépendants
4. **Debug simple** : Moins de magie = moins de bugs

### Cas d'usage typiques

**Store Svelte :** Données partagées entre multiple composants, état global
**Props :** Données simples parent → enfant, configuration
**`$derived` :** Calculs basés sur d'autres états réactifs
**`$effect` :** Effets de bord (logs, API calls, DOM manipulation)

### Exemple concret : Badges réactifs

```typescript
// Store pour les mappings
export const mappedFields = writable({});

// Composant parent
function autoMap() {
    mappedFields.set({0: 'field1', 1: 'field2'});
}

// Composant enfant
let mappedFields = $derived($mappedFieldsStore);
let badgeColor = $derived(isFieldMapped ? 'vert' : 'rouge');

// Résultat : Badges se mettent à jour automatiquement !
```

Cette approche garantit une réactivité fiable et prévisible dans toute l'application.

# Règles de développement pour ImportData

## Environnement et outils

- Utiliser **pnpm** comme gestionnaire de paquets (jamais npm)
- Stack : SvelteKit + TypeScript + PostgreSQL + Prisma + TailwindCSS
- Authentification via Logto
- Tests avec Vitest

## Commandes essentielles

**Développement :**

```bash
pnpm dev                  # Serveur de développement
pnpm build && pnpm preview  # Build et aperçu
pnpm lint && pnpm format  # Qualité du code
pnpm check                # Vérification TypeScript
pnpm test:unit            # Tests unitaires
```

**Prisma - CENOV (Production) :**

```bash
pnpm prisma:generate      # Génération client Prisma
pnpm prisma:migrate       # Migrations base de données
pnpm prisma:studio        # Interface Prisma Studio
pnpm prisma:push          # Push schéma vers BDD
pnpm prisma:pull          # Pull schéma depuis BDD
```

**Prisma - CENOV_DEV (Développement) :**

```bash
pnpm prisma:generate-dev  # Génération client dev
pnpm prisma:migrate-dev   # Migrations dev
pnpm prisma:studio-dev    # Studio dev
pnpm prisma:push-dev      # Push schéma dev
pnpm prisma:pull-dev      # Pull schéma dev
```

**Clients Prisma :**

```bash
pnpm prisma:generate-all  # Génération des deux clients
```

**Scripts BDD-IA (Export base de données) :**

```bash
node scripts/BDD-IA/fetch-all-tables.mjs    # Export toutes les tables
node scripts/BDD-IA/fetch-all-views.mjs     # Export toutes les vues
node scripts/BDD-IA/fetch-cenov-data.mjs    # Export complet (recommandé)
```

## Architecture et fichiers clés

- `src/routes/` : Pages SvelteKit (categories, kits, import, products)
- `src/lib/components/` : Composants réutilisables + UI library
- `src/lib/schemas/dbSchema.ts` : Schémas Zod pour validation
- `prisma/cenov/schema.prisma` : Schéma principal base de données CENOV
- `prisma/cenov_dev/schema.prisma` : Schéma base de données CENOV_DEV

## Workflow Prisma

1. Éditer `prisma/cenov/schema.prisma` (ou `prisma/cenov_dev/schema.prisma`)
2. Exécuter les commandes Prisma directement sur le schéma principal

## Base de données

**Architecture double base :**

- **CENOV Database** (`DATABASE_URL`) - Base principale production
- **CENOV_DEV Database** (`CENOV_DEV_DATABASE_URL`) - Base développement étendue

**Clients Prisma :**

```typescript
// Base CENOV (principale) :
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

// Base CENOV_DEV :
import { PrismaClient as CenovDevPrismaClient } from '../../prisma/cenov_dev/generated';
const cenovDevPrisma = new CenovDevPrismaClient();
```

## Principe Anti-Hardcoding avec Prisma DMMF

**RÈGLE :** Toujours vérifier si un hardcoding peut être remplacé par des métadonnées Prisma DMMF.

```typescript
// ❌ MAUVAIS - Hardcoding de données DB
const databases = ['cenov', 'cenov_dev'];
if (dbName !== 'cenov' && dbName !== 'cenov_dev') throw new Error('BDD inconnue');
if (database === 'cenov') return 1;

// ✅ BON - Utiliser Prisma DMMF
const databases = await getAllDatabaseNames();
if (!validDatabases.includes(dbName)) throw new Error(`BDD inconnue`);
return a.database.localeCompare(b.database);

// ✅ OK - Config UI acceptable
export const DATABASE_CONFIG = { cenov: { icon: RocketIcon, variant: 'bleu' } };
const schema = metadata.schema || 'public'; // Standard SQL
```

**Fonctions DMMF :** `getAllDatabaseNames()`, `getTableMetadata()`, `getAllDatabaseTables()`

**Règle :** Données DB → Prisma DMMF | UI/Config → Fichier centralisé

**Métadonnées Prisma :**

- Utiliser `src/lib/prisma-meta.ts` pour métadonnées centralisées
- Éviter valeurs hardcodées, utiliser Prisma DMMF
- Fonctions : `getDatabases()`, `getTableMetadata()`, `getAllTables()`

## Conventions de code

- camelCase pour fonctions et variables
- Typage strict TypeScript - **ÉVITER `any`, utiliser `unknown`**
- Programmation fonctionnelle privilégiée
- async/await plutôt que callbacks
- Early returns pour éviter imbrication
- const/let jamais var
- Template literals plutôt que concaténation
- Gestion erreurs explicite avec try/catch
- Fonctions pures sans effets de bord
- Principes DRY, KISS, YAGNI

**TypeScript - Remplacements recommandés :**

```typescript
// ❌ Éviter
const data: any[] = [];
const previewData: Record<string, any[]> = {};

// ✅ Utiliser
const data: unknown[] = [];
const previewData: Record<string, unknown[]> = {};
```

## Authentification

- Routes protégées via `src/lib/auth/protect.ts`
- Gestion session dans layouts
- Callback OAuth dans `/authentication-callback`

## Import Excel

- Fonctionnalité import dans `/import` et `/products/import`
- Support catégories, attributs, hiérarchies kits

## Tests

- Tests d'intégration dans `tests/integration/`
- CRUD operations pour categories et kits
- Tests de fonctionnalité import

## Composants UI

- Composants personnalisés basés sur bits-ui et Flowbite
- Validation formulaires avec Zod + SvelteKit Superforms
- Structure dans `src/lib/components/ui/`

**Button variants :**

- `bleu` (default) - Primary blue button
- `vert` - Success/confirmation actions
- `rouge` - Danger/delete actions
- `jaune` - Warning actions
- `noir` - Secondary dark actions
- `blanc` - Alternative/outline style
- `link` - Text link style

**Note:** `outline` variant n'existe pas - utiliser `blanc` pour style outline.

**Badge variants :**

- `default` (default) - Primary badge style
- `bleu` - Blue informational badge
- `vert` - Success/positive badge
- `rouge` - Error/danger badge
- `noir` - Secondary/neutral badge
- `blanc` - Alternative/outline style badge
- `orange` - Modification badge

**Note:** `outline` variant n'existe pas pour badges - utiliser `blanc` pour style outline.

### Intégration Icônes Badge

**IMPORTANT:** Le composant Badge gère automatiquement les icônes SVG avec style intégré :

```typescript
// ✅ CORRECT - Laisser le composant gérer taille et espacement
<Badge variant="vert">
  <Eye />
  Vues
</Badge>

// ❌ MAUVAIS - Ne pas ajouter manuellement classes taille/espacement
<Badge variant="vert">
  <Eye class="mr-1 h-3 w-3" />
  Vues
</Badge>
```

**Style Icône Badge Intégré :**

- `[&>svg]:size-3` - Toutes icônes SVG obtiennent automatiquement `size-3` (12x12px)
- `[&>svg]:pointer-events-none` - Icônes n'interfèrent pas avec événements clic
- `gap-1` - Espacement automatique entre icône et texte
- `items-center justify-center` - Alignement parfait

**Bonne Pratique :** Toujours lire les classes CSS du composant avant d'ajouter style manuel. La plupart des composants UI gèrent les icônes nativement.

## Toast Notifications (Sonner)

**Setup :** svelte-sonner installé, Toaster configuré dans +layout.svelte

**Usage correct :**

```typescript
// ✅ Import correct
import { toast } from 'svelte-sonner';
import { Toaster } from 'svelte-sonner';

// ✅ Usage
toast.error("Message d'erreur");
toast.success('Opération réussie');
toast('Message info');
```

**Erreurs à éviter :**

```typescript
// ❌ N'JAMAIS importer depuis les composants UI
import { toast } from '$lib/components/ui/sonner';
```

### Bonnes Pratiques Timing

- **Toasts au chargement page :** Utiliser `setTimeout` avec petit délai (100ms) dans `onMount`
- **Gestionnaires événements :** Appeler directement sans délai
- **Après navigation :** Fonctionne immédiatement après redirections

### Intégration Authentification

Le projet a des toasts d'erreur auth intégrés :

- Routes protégées affichent automatiquement toast si accès non autorisé
- Géré via paramètres URL et `onMount` dans homepage

## Debugging Réactivité Svelte

**Problème courant :** `console.log` maintiennent accidentellement la réactivité dans Svelte 4.

**Symptôme :** Fonctionnalité casse après suppression de logs "innocents".

### Diagnostic rapide

```bash
# Identifier les logs suspects
grep -n "console\.(log\|warn\|error)" src/routes/export/*.svelte
grep -rn "\$:.*console" src/routes/
```

**Patterns dangereux :**

- `$: { ... console.log(...) ... }` ← Suspect
- `$: console.log(...)` ← Très suspect
- Dans `$effect(() => { console.log(...) })` ← OK (informatif)

### Migration Svelte 5 (solution)

```typescript
// ❌ ANCIEN - Hack réactif avec console.log
$: if (step === 3 && data.length > 0 && !config) {
	config = { ...formData };
	console.log('Config sauvée:', config); // ← Force la réactivité !
}

// ✅ NOUVEAU - Svelte 5 propre
let config = $state(null);
let shouldSaveConfig = $derived(step === 3 && data.length > 0 && !config);

$effect(() => {
	if (shouldSaveConfig) {
		config = { ...formData };
		console.log('Config sauvée:', config); // ← Informatif seulement
	}
});
```

### Patterns de migration

```typescript
// Variables d'état
export let data;              → let { data } = $props();
let state = value;            → let state = $state(value);

// Réactivité
$: derived = compute(data);   → let derived = $derived(compute(data));
$: { sideEffect(); }         → $effect(() => { sideEffect(); });

// Composants dynamiques
<svelte:component this={C} /> → {@const Component = C} <Component />
```

### Vérification post-migration

```bash
# Ces commandes doivent retourner vide après migration
grep -rn "export let" src/routes/
grep -rn "svelte:component" src/routes/
grep -rn "console\.log.*\$" src/routes/      # Console.log dans réactivité
grep -rn "\$:.*console" src/routes/          # Réactivité avec console
```

**Règle d'or :** Supprimer tous les `console.log` ne doit jamais casser la logique.

## Réponses en français

- Toujours répondre en français
- Être concis, éviter phrases de remplissage
- Montrer seulement lignes changées avec contexte minimal
- Anticiper besoins et suggérer solutions

## Résolution Conflits Édition Fichiers

**Lors d'erreurs "File has been unexpectedly modified" :**

Cela se produit typiquement quand fichiers sont automatiquement formatés par linters/formatters (Prettier, ESLint) après lecture.

**Étapes de résolution :**

1. **Utiliser chemins Windows absolus D'ABORD :** Toujours utiliser chemins Windows absolus avec lettres de lecteur et backslashes pour TOUTES opérations fichiers :

   ```bash
   # ✅ CORRECT - Utiliser chemins Windows absolus
   C:\Users\EwanSenergous\OneDrive - jll.spear\Bureau\Projet\importData\file.js

   # ❌ MAUVAIS - Chemins relatifs ou style Unix peuvent échouer
   ./file.js
   /c/Users/.../file.js
   ```

2. **Git restore (si chemins absolus ne fonctionnent pas) :** Si conflits persistent, restaurer le fichier à son état original :

   ```bash
   git restore path/to/file.svelte
   ```

3. **Relire avant édition :** Toujours utiliser outil Read pour obtenir dernier état fichier avant édition

4. **Comportement attendu :** Les linters peuvent formater automatiquement, c'est intentionnel et doit être préservé

**Scénarios courants :**

- Prettier reformate espacement et sauts de ligne
- ESLint corrige automatiquement problèmes de style
- Ces changements sont intentionnels et améliorent qualité du code

**Bonnes pratiques :**

- **TOUJOURS essayer chemins Windows absolus d'abord** avant d'utiliser git restore
- Ne pas annuler changements linter sauf demande explicite
- Utiliser git restore seulement quand chemins absolus et conflits bloquent progression
- Relire fichiers après formatage pour obtenir état actuel

**Appliquer chemins Windows absolus à tous les outils :**

- Outil Read: Toujours utiliser chemins `C:\...`
- Outil Write: Toujours utiliser chemins `C:\...`
- Outil Edit: Toujours utiliser chemins `C:\...`
- Outil MultiEdit: Toujours utiliser chemins `C:\...`
